<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8"/>
    <title>Combined Q&A Recorder & Text Reader (Chinese)</title>
    <style>
        /* CSS styles remain the same */
        html, body {
            height: 100%;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            overflow: hidden;
        }
        #main-container {
            display: flex;
            height: 100vh;
        }
        .panel {
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto;
            height: 100vh;
        }
        #left-panel {
            background-color: #f8f9fa;
            border-right: 2px solid #dee2e6;
        }
        #right-panel {
            background-color: #ffffff;
            resize: horizontal;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        h1, h2 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }
        button {
            padding: 8px 16px;
            margin: 5px 5px 5px 0;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #e9ecef;
        }
        button:hover {
            background-color: #d8dde2;
        }
        .question-block {
            background: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .question-text {
            font-size: 1.1em;
            margin-bottom: 10px;
            padding: 6px;
            border: 1px dashed transparent;
        }
        .question-text[contenteditable="true"]:focus {
            border: 1px dashed #888;
            background-color: #f0f8ff;
            outline: none;
        }
        .answer {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
            min-height: 30px;
            border: 1px solid #ddd;
            line-height: 1.6;
        }
        .audio-status {
            display: inline-block;
            margin-left: 6px;
            color: green;
            font-weight: bold;
            visibility: hidden;
        }
        .audio-status.visible {
            visibility: visible;
        }
        input[type="file"] {
            margin: 10px 0;
        }
        textarea {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        .model-answer {
             background-color: #e6ffed;
        }
        .score-display {
            font-weight: bold;
            color: #0056b3;
            margin-left: 10px;
        }
        #text-area {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 18px;
            overflow: auto;
            box-sizing: border-box;
            flex-grow: 1;
        }
        #controls-right {
            padding-top: 10px;
        }
        #tts-controls {
            margin-bottom: 10px;
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
        }
        #tts-controls label {
            margin-right: 10px;
        }
        #speed-slider {
            vertical-align: middle;
        }
        #speed-value {
            font-weight: bold;
            color: #333;
        }
        .reading-highlight {
            background-color: rgb(173, 216, 230);
        }
    </style>
</head>
<body>

<div id="main-container">
    <div id="left-panel" class="panel">
        <h1>Questions and Answers ‚Äì Voice Recording</h1>
        <h2>üìÇ Import questions from file:</h2>
        <input accept=".docx,.txt" id="file-input" type="file"/>
        <h2>üì• Import Q&A from ZIP:</h2>
        <input type="file" id="zip-input" accept=".zip">
        <div id="questions-container">
            </div>
        <button onclick="addNewQuestion()">‚ûï Add New Question</button>
        <button onclick="exportData()">üì§ Export Data to ZIP</button>
        <button id="toggle-model-answers-btn" onclick="toggleModelAnswers()">·∫®n c√¢u tr·∫£ l·ªùi m·∫´u</button>
        <button onclick="createNewSession()">‚ûï Create New Session</button>
    </div>

    <div id="right-panel" class="panel">
        <h1>Paste text here to listen</h1>
        <div id="text-area" contenteditable="true">
            Paste text here...
        </div>
        <div id="controls-right">
             <div id="tts-controls">
                <label for="speed-slider">T·ªëc ƒë·ªô ƒë·ªçc:</label>
                <input type="range" id="speed-slider" min="0.5" max="2" value="1" step="0.1">
                <span id="speed-value">1.0x</span>
            </div>
            <button id="read-all">üîä Read All Text</button>
            <button id="read-current-sentence">üîä Read Current Sentence</button>
            <button id="highlight-button">üé® Highlight</button>
            <button id="remove-highlight-button">üóëÔ∏è X√≥a Highlight</button>
        </div>
    </div>
</div>
<script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jieba-js/dist/jieba.min.js"></script>


<script>
    let recognition;
    let mediaRecorder;
    let audioChunks = [];
    const audioBlobs = {};
    let currentAnswerIndex = null;
    let currentAudioIndex = null;
    let questionCount = 0;
    let currentPlaybackRate = 1.0;
    let isReading = false;
    let currentUtterance = null;
    let areModelAnswersVisible = true;
    let chineseTTSVoice = null;

    function initializeVoices() {
        const voices = speechSynthesis.getVoices();
        const targetVoiceName = "Microsoft Xiaoxiao Online (Natural) - Chinese (Mainland)";
        chineseTTSVoice = voices.find(v => v.name === targetVoiceName);

        if (chineseTTSVoice) {
            console.log("Successfully found Chinese voice:", chineseTTSVoice.name);
        } else {
            console.warn(`Voice "${targetVoiceName}" not found. The browser's default Chinese voice will be used.`);
        }
    }

    if (!('webkitSpeechRecognition' in window)) {
        alert('Speech recognition not supported in this browser.');
    } else {
        recognition = new webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = false;
        recognition.lang = 'zh-CN';
        
        recognition.onresult = function (event) {
            let transcript = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    transcript += event.results[i][0].transcript.replace(/[.,„ÄÇ]/g, '');
                }
            }
            if (currentAnswerIndex !== null && transcript) {
                const segmentedTranscript = jieba_cut(transcript).join(' '); 
                const answerBox = document.getElementById(`answer-${currentAnswerIndex}`);
                answerBox.innerHTML = (answerBox.textContent.trim() ? answerBox.textContent.trim() + ' ' : '') + segmentedTranscript;
            }
        };

        recognition.onerror = function (event) {
            console.error('Speech recognition error:', event.error);
        };
    }

    // ======================================================= -->
    // =============== LOGIC ƒê·ªåC V√Ä T√î S√ÅNG ƒê√É VI·∫æT L·∫†I HO√ÄN TO√ÄN ============== -->
    // ======================================================= -->

    function speak(text) {
        if (isReading) {
            speechSynthesis.cancel();
        }

        const textArea = document.getElementById('text-area');
        const cleanedText = text.replace(/[\u2500-\u25FF\u2B00-\u2BFF]/g, '')
                                .replace(/\s+/g, ' ')
                                .trim();
        
        if (!cleanedText) {
            isReading = false;
            return;
        }
        
        // B1: Chu·∫©n b·ªã HTML ƒë·ªÉ t√¥ s√°ng b·∫±ng c√°ch b·ªçc m·ªói t·ª´ trong th·∫ª span
        const words = cleanedText.split(/\s+/).filter(Boolean);
        textArea.innerHTML = words.map((word, index) => `<span class="readable-word" id="word-${index}">${word}</span>`).join(' ');
        
        const wordSpans = textArea.querySelectorAll('.readable-word');
        let currentWordIndex = 0;

        currentUtterance = new SpeechSynthesisUtterance(cleanedText);
        currentUtterance.lang = 'zh-CN';
        
        if (chineseTTSVoice) {
            currentUtterance.voice = chineseTTSVoice;
        }

        currentUtterance.rate = currentPlaybackRate;
        
        currentUtterance.onstart = function() {
            isReading = true;
        };

        // B2: D√πng s·ª± ki·ªán onboundary ƒë·ªÉ t√¥ s√°ng t·ª´ng span t∆∞∆°ng ·ª©ng
        currentUtterance.onboundary = function(event) {
            if (event.name === 'word') {
                // X√≥a highlight c·ªßa t·ª´ tr∆∞·ªõc ƒë√≥
                if (currentWordIndex > 0) {
                    wordSpans[currentWordIndex - 1].classList.remove('reading-highlight');
                }
                // Highlight t·ª´ hi·ªán t·∫°i
                if (currentWordIndex < wordSpans.length) {
                    wordSpans[currentWordIndex].classList.add('reading-highlight');
                    currentWordIndex++;
                }
            }
        };

        currentUtterance.onend = function() {
            isReading = false;
            // X√≥a highlight c·ªßa t·ª´ cu·ªëi c√πng
            if (wordSpans.length > 0) {
                 wordSpans[wordSpans.length - 1].classList.remove('reading-highlight');
            }
            currentUtterance = null;
        };
        
        speechSynthesis.speak(currentUtterance);
    }
    
    // H√†m getTextContentOfTextArea kh√¥ng c·∫ßn ph·ª©c t·∫°p n·ªØa
    function getTextContentOfTextArea(element) {
        return element.innerText || element.textContent;
    }

    // ======================================================= -->
    // ======================================================= -->
    
    function startRecognition(index) {
        currentAnswerIndex = index;
        if (recognition) {
            const answerBox = document.getElementById(`answer-${currentAnswerIndex}`);
            answerBox.innerHTML = '';
            recognition.start();
        }
        startAudioRecording(index);
    }

    function stopRecognition() {
        if (recognition) recognition.stop();
        stopAudioRecording();
    }
    
    async function startAudioRecording(index) {
        currentAudioIndex = index;
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                audioBlobs[currentAudioIndex] = blob;
                const audioURL = URL.createObjectURL(blob);
                const audioElement = document.getElementById(`audio-${currentAudioIndex}`);
                audioElement.src = audioURL;
                audioElement.style.display = 'block';
                showAudioStatus(currentAudioIndex);
            };
            mediaRecorder.start();
        } catch (err) {
            console.error("Error starting audio recording:", err);
            alert("Could not start audio recording. Please grant microphone permissions.");
        }
    }

    function stopAudioRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
    }

    function playAudio(index) {
        const audio = document.getElementById(`audio-${index}`);
        if(audio.src) {
           audio.play();
        } else {
            alert("No audio recorded for this question yet.");
        }
    }
    
    function speakQuestion(index) {
        const text = document.querySelector(`.question-block[data-index="${index}"] .question-text`).textContent;
        // T·∫°m th·ªùi d√πng h√†m alert cho vi·ªác ƒë·ªçc c√¢u h·ªèi ƒë·ªÉ tr√°nh xung ƒë·ªôt v·ªõi logic t√¥ s√°ng
        alert("Ch·ª©c nƒÉng ƒë·ªçc c√¢u h·ªèi ƒëang ƒë∆∞·ª£c t·∫°m t·∫Øt ƒë·ªÉ ∆∞u ti√™n cho ph·∫ßn ƒë·ªçc vƒÉn b·∫£n b√™n ph·∫£i. Vui l√≤ng copy c√¢u h·ªèi sang b√™n ph·∫£i ƒë·ªÉ nghe.");
        // speak(text); // T·∫°m th·ªùi v√¥ hi·ªáu h√≥a
    }

    function addNewQuestion() {
        const container = document.getElementById('questions-container');
        const index = questionCount;
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question-block';
        questionDiv.setAttribute('data-index', index);
        questionDiv.innerHTML = `
            <div class="question-text" contenteditable="true">${index + 1}. </div>
            <button onclick="speakQuestion(${index})">üîà Read</button>
            <button onclick="startRecognition(${index})">üé§ Start Recording</button>
            <button onclick="stopRecognition()">üõë Stop</button>
            <button onclick="playAudio(${index})">‚ñ∂Ô∏è Play</button>
            <span class="audio-status" id="audio-status-${index}">üîä</span>
            <div class="answer" id="answer-${index}"></div>
            <textarea placeholder="‚úçÔ∏è Type your answer here..." style="width: 100%;"></textarea>
            <textarea class="model-answer" placeholder="‚úçÔ∏è Nh·∫≠p c√¢u tr·∫£ l·ªùi m·∫´u ·ªü ƒë√¢y..."></textarea>
            <button onclick="scoreAnswer(${index})">‚≠ê Ch·∫•m ƒëi·ªÉm</button>
            <span class="score-display" id="score-display-${index}"></span>
            <audio id="audio-${index}" controls style="display: none;"></audio>
        `;
        container.appendChild(questionDiv);
        questionCount++;
    }

    function showAudioStatus(index) {
        const statusIcon = document.getElementById(`audio-status-${index}`);
        if (statusIcon) statusIcon.classList.add("visible");
    }

    function createNewSession() {
        window.open(window.location.pathname + `?id=${Date.now()}_${Math.floor(Math.random() * 100000)}`, '_blank');
    }
    
    function toggleModelAnswers() {
        const modelAnswers = document.querySelectorAll('.model-answer');
        const button = document.getElementById('toggle-model-answers-btn');
        areModelAnswersVisible = !areModelAnswersVisible;
        
        modelAnswers.forEach(answer => {
            answer.style.display = areModelAnswersVisible ? 'block' : 'none';
        });

        button.textContent = areModelAnswersVisible ? '·∫®n c√¢u tr·∫£ l·ªùi m·∫´u' : 'Hi·ªán c√¢u tr·∫£ l·ªùi m·∫´u';
    }
    
    function processImportedQuestionsAndAnswers(text) {
        document.getElementById("questions-container").innerHTML = '';
        questionCount = 0;
        
        const lines = text.split(/\r?\n/);
        const qaPairs = [];
        
        lines.forEach(line => {
            const trimmedLine = line.trim();
            if (!trimmedLine) return;

            if (trimmedLine.startsWith('[A]')) {
                if (qaPairs.length > 0) {
                    qaPairs[qaPairs.length - 1].answer = trimmedLine.substring(3).trim();
                }
            } else {
                qaPairs.push({ question: trimmedLine, answer: '' });
            }
        });
        
        qaPairs.forEach(pair => {
            if (!pair.question) return;
            addNewQuestion();
            const newBlock = document.querySelector(`.question-block[data-index="${questionCount - 1}"]`);
            newBlock.querySelector(".question-text").textContent = pair.question;
            if (pair.answer) {
                 newBlock.querySelector(".model-answer").value = pair.answer;
            }
        });
    }

    document.getElementById("file-input").addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (!file) return;

        if (file.name.endsWith(".txt")) {
            const reader = new FileReader();
            reader.onload = () => processImportedQuestionsAndAnswers(reader.result);
            reader.readAsText(file);
        } else if (file.name.endsWith(".docx")) {
            const reader = new FileReader();
            reader.onload = (e) => {
                mammoth.extractRawText({ arrayBuffer: e.target.result })
                    .then(result => processImportedQuestionsAndAnswers(result.value));
            };
            reader.readAsArrayBuffer(file);
        }
    });

    function exportData() {
        const zip = new JSZip();
        const blocks = document.querySelectorAll(".question-block");
        let qaContent = "";
        const modelAnswerToken = "[model_answer]";
        const answerToken = "Answer:";
        blocks.forEach((block) => {
            const index = block.getAttribute('data-index');
            const question = block.querySelector(".question-text").textContent.trim();
            const modelAnswer = block.querySelector(".model-answer").value.trim();
            const voiceAnswer = block.querySelector(".answer").textContent.trim();
            const typedAnswer = block.querySelector("textarea:not(.model-answer)").value.trim();
            const finalAnswer = typedAnswer || voiceAnswer;
            qaContent += `${question}\n`;
            if (modelAnswer) {
                qaContent += `${modelAnswerToken}${modelAnswer}\n`;
            }
            qaContent += `${answerToken} ${finalAnswer}\n\n`;
            if (audioBlobs[index]) zip.file(`audio_${parseInt(index) + 1}.webm`, audioBlobs[index]);
        });
        zip.file("qa_export.txt", qaContent);
        const rightPanelHtml = document.getElementById('text-area').innerHTML;
        if (rightPanelHtml && rightPanelHtml !== 'Paste text here...') {
            zip.file("reading_text.html", rightPanelHtml);
        }
        zip.generateAsync({ type: "blob" }).then(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `export_session_${Date.now()}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    }

    document.getElementById('zip-input').addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (!file) return;
        const zip = new JSZip();
        zip.loadAsync(file).then(async function (zipContent) {
            const qaFile = zipContent.file("qa_export.txt");
            if (qaFile) {
                const qaText = await qaFile.async("string");
                const entries = qaText.split('\n\n').filter(Boolean);
                document.getElementById("questions-container").innerHTML = '';
                questionCount = 0;
                Object.keys(audioBlobs).forEach(key => delete audioBlobs[key]);
                const modelAnswerToken = "[model_answer]";
                const answerToken = "Answer: ";
                for (const entry of entries) {
                    const lines = entry.split('\n').filter(Boolean);
                    if (lines.length === 0) continue;
                    const questionLine = lines[0];
                    let modelAnswerLine = '';
                    let answerLine = '';
                    lines.forEach(line => {
                        if (line.startsWith(modelAnswerToken)) {
                            modelAnswerLine = line.substring(modelAnswerToken.length);
                        } else if (line.startsWith(answerToken)) {
                            answerLine = line.substring(answerToken.length);
                        }
                    });
                    addNewQuestion();
                    const index = questionCount - 1;
                    const qBlock = document.querySelector(`.question-block[data-index="${index}"]`);
                    qBlock.querySelector(".question-text").textContent = questionLine.trim();
                    if(modelAnswerLine) qBlock.querySelector(".model-answer").value = modelAnswerLine.trim();
                    const answerDiv = qBlock.querySelector(".answer");
                    const typedAnswerTextarea = qBlock.querySelector("textarea:not(.model-answer)");
                    if (answerLine) {
                         typedAnswerTextarea.value = answerLine.trim();
                         answerDiv.textContent = '';
                    }
                    const audioFile = zipContent.file(`audio_${index + 1}.webm`);
                    if (audioFile) {
                        const blob = await audioFile.async("blob");
                        audioBlobs[index] = blob;
                        const audioURL = URL.createObjectURL(blob);
                        const audioElement = qBlock.querySelector("audio");
                        audioElement.src = audioURL;
                        audioElement.style.display = "block";
                        showAudioStatus(index);
                    }
                }
            }
            const readingTextHtmlFile = zipContent.file("reading_text.html");
            if (readingTextHtmlFile) {
                document.getElementById('text-area').innerHTML = await readingTextHtmlFile.async("string");
            }
        });
    });

    function levenshteinDistance(s1, s2) {
        const cleanS1 = s1.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu, '');
        const cleanS2 = s2.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu, '');
        const costs = [];
        for (let i = 0; i <= cleanS1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= cleanS2.length; j++) {
                if (i == 0) { costs[j] = j; }
                else {
                    if (j > 0) {
                        let newValue = costs[j - 1];
                        if (cleanS1.charAt(i - 1) != cleanS2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
            }
            if (i > 0) costs[cleanS2.length] = lastValue;
        }
        return costs[cleanS2.length];
    }

    function computeLCS(words1, words2) {
        const m = words1.length;
        const n = words2.length;
        const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                const cleanWord1 = words1[i - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
                const cleanWord2 = words2[j - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
                if (cleanWord1 === cleanWord2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp;
    }

    function generateDiff(userWords, modelWords, dp) {
        let i = userWords.length, j = modelWords.length;
        const diff = [];
        while (i > 0 && j > 0) {
            const cleanUserWord = userWords[i - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
            const cleanModelWord = modelWords[j - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
            if (cleanUserWord === cleanModelWord) {
                diff.unshift({ type: 'correct', text: userWords[i - 1] });
                i--; j--;
            } else if (dp[i - 1][j] >= dp[i][j - 1]) {
                diff.unshift({ type: 'incorrect', text: userWords[i - 1] });
                i--;
            } else {
                j--;
            }
        }
        while (i > 0) {
            diff.unshift({ type: 'incorrect', text: userWords[i - 1] });
            i--;
        }
        return diff;
    }

    function scoreAnswer(index) {
        const modelAnswer = document.querySelector(`.question-block[data-index="${index}"] .model-answer`).value.trim();
        const userAnswerDiv = document.getElementById(`answer-${index}`);
        const typedAnswer = document.querySelector(`.question-block[data-index="${index}"] textarea:not(.model-answer)`).value.trim();
        let userAnswer;
        
        if (typedAnswer) { 
            userAnswer = typedAnswer;
        } else {
            userAnswer = userAnswerDiv.textContent.trim();
        }

        const scoreDisplay = document.getElementById(`score-display-${index}`);
        if (!modelAnswer) { alert("Vui l√≤ng nh·∫≠p c√¢u tr·∫£ l·ªùi m·∫´u ƒë·ªÉ ch·∫•m ƒëi·ªÉm."); return; }
        if (!userAnswer) { alert("Vui l√≤ng ghi √¢m ho·∫∑c nh·∫≠p c√¢u tr·∫£ l·ªùi tr∆∞·ªõc khi ch·∫•m ƒëi·ªÉm."); return; }
        const distance = levenshteinDistance(modelAnswer, userAnswer);
        const longerLength = Math.max(modelAnswer.length, userAnswer.length);
        if (longerLength === 0) { scoreDisplay.textContent = "Score: 100%"; }
        else {
             const similarity = (1 - (distance / longerLength)) * 100;
             scoreDisplay.textContent = `Score: ${Math.round(similarity)}%`;
        }
        const userWords = userAnswer.split(/\s+/).filter(Boolean);
        const modelWords = modelAnswer.split(/\s+/).filter(Boolean);
        const dp = computeLCS(userWords, modelWords);
        const diff = generateDiff(userWords, modelWords, dp);
        const highlightedHtml = diff.map(part => {
            const color = part.type === 'correct' ? 'green' : 'red';
            const escapedText = part.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return `<span style="color: ${color};">${escapedText}</span>`;
        }).join(' ');
        
        userAnswerDiv.innerHTML = highlightedHtml || '';
    }

    document.getElementById("text-area").addEventListener("mouseup", function () {
        setTimeout(() => {
            const selection = window.getSelection();
            if (selection.isCollapsed || !selection.toString().trim()) {
                return;
            }
            speak(selection.toString());
        }, 100);
    });

    document.getElementById("read-all").addEventListener("click", function () {
        const textArea = document.getElementById("text-area");
        const fullTextToSpeak = getTextContentOfTextArea(textArea);
        if (fullTextToSpeak && fullTextToSpeak.trim() !== 'Paste text here...') {
            speak(fullTextToSpeak);
        } else {
            alert("There is no text to read!");
        }
    });

    // ======================================================= -->
    // ============= LOGIC ƒê·ªåC C√ÇU HI·ªÜN T·∫†I ƒê√É S·ª¨A L·∫†I ============== -->
    // ======================================================= -->
    document.getElementById("read-current-sentence").addEventListener("click", function() {
        const textArea = document.getElementById('text-area');
        const selection = window.getSelection();

        if (selection.rangeCount === 0) {
            alert("Vui l√≤ng ƒë·∫∑t con tr·ªè chu·ªôt v√†o v·ªã tr√≠ mu·ªën ƒë·ªçc ho·∫∑c ch·ªçn m·ªôt ƒëo·∫°n vƒÉn b·∫£n.");
            return;
        }

        const fullText = getTextContentOfTextArea(textArea);
        const range = selection.getRangeAt(0);
        const preCursorRange = range.cloneRange();
        preCursorRange.selectNodeContents(textArea);
        preCursorRange.setEnd(range.startContainer, range.startOffset);
        const cursorPosition = preCursorRange.toString().length;

        let sentenceStart = cursorPosition;
        while (sentenceStart > 0) {
            const char = fullText[sentenceStart - 1];
            if ('.?!„ÄÇÔºüÔºÅ\n'.includes(char)) {
                break;
            }
            sentenceStart--;
        }

        let sentenceEnd = cursorPosition;
        while (sentenceEnd < fullText.length) {
            const char = fullText[sentenceEnd];
            if ('.?!„ÄÇÔºüÔºÅ\n'.includes(char)) {
                break;
            }
            sentenceEnd++;
        }

        let sentenceToRead = fullText.substring(sentenceStart, sentenceEnd + 1).trim();

        if (sentenceToRead) {
            speak(sentenceToRead);
        } else {
            alert("Kh√¥ng t√¨m th·∫•y c√¢u ƒë·ªÉ ƒë·ªçc t·∫°i v·ªã tr√≠ con tr·ªè.");
        }
    });


    document.getElementById("highlight-button").addEventListener("click", function () {
        const selection = window.getSelection();
        if (!selection.rangeCount || selection.isCollapsed) return;
        const color = highlightColors[currentColorIndex];
        document.execCommand('backColor', false, color);
        currentColorIndex = (currentColorIndex + 1) % highlightColors.length;
    });

    document.getElementById("remove-highlight-button").addEventListener("click", function () {
        const selection = window.getSelection();
        if (!selection.rangeCount || selection.isCollapsed) return;
        document.execCommand('backColor', false, 'transparent');
    });

    const speedSlider = document.getElementById('speed-slider');
    const speedValue = document.getElementById('speed-value');
    speedSlider.addEventListener('input', function() {
        currentPlaybackRate = parseFloat(this.value);
        speedValue.textContent = `${currentPlaybackRate.toFixed(1)}x`;
    });

    window.onload = () => {
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = initializeVoices;
        }
        initializeVoices();
        
        document.getElementById("questions-container").innerHTML = '';
        questionCount = 0;
        addNewQuestion();
    };
</script>
</body>
</html>
