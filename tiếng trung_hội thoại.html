<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luy·ªán N√≥i Ti·∫øng Anh Pro - N√¢ng C·∫•p</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align top */
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 700px;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 30px;
            text-align: center;
        }
        h1 {
            color: #0d6efd;
            margin-bottom: 25px;
        }
        h2 {
            font-size: 1.2rem;
            color: #495057;
            margin-bottom: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 5px;
        }
        textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 12px;
            border: 1px solid #ced4da;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 10px;
            resize: vertical;
        }
        .controls, .session-controls {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        button {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover {
            background-color: #0b5ed7;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button#record-btn { background-color: #198754; }
        button#record-btn:hover { background-color: #157347; }
        .dialogue-box { margin-top: 20px; padding: 15px; background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; text-align: left; }
        .line { padding: 12px; margin: 8px 0; border-radius: 8px; font-size: 1.1rem; }
        .computer-line { background-color: #e7f3ff; }
        .user-line { background-color: #fff3cd; font-weight: bold; border: 2px dashed #ffc107; }
        .status { margin-top: 20px; font-size: 1.1rem; font-weight: bold; min-height: 50px; padding: 10px; border-radius: 8px;}
        .status.success { color: #146c43; background-color: #d1e7dd; }
        .status.error { color: #b02a37; background-color: #f8d7da; }
        .instructions { font-size: 0.9rem; color: #606770; text-align: left; margin-bottom: 20px; background: #eef; padding: 15px; border-radius: 8px; border-left: 4px solid #0d6efd; }
        #review-area { text-align: left; margin-top: 20px; }
        .review-line { padding: 12px; margin: 8px 0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; }
        .review-line.computer { background-color: #e7f3ff; }
        .review-line.user { background-color: #d1e7dd; font-weight: 500;}
        .play-recording-btn { background-color: #fd7e14; padding: 6px 12px; font-size: 0.9rem; }
        .play-recording-btn:hover { background-color: #e46e0e; }
        #restart-btn { background-color: #6c757d; }
        #restart-btn:hover { background-color: #5a6268; }
        #play-all-btn { background-color: #0dcaf0; }
        #play-all-btn:hover { background-color: #0aa8c2; }
        
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            text-align: left;
        }
        .difficulty-selection, .custom-feedback-area {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .difficulty-selection fieldset {
            border: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: space-around;
        }
        .difficulty-selection legend {
            font-weight: bold;
            margin-bottom: 10px;
            width: 100%;
        }
        .feedback-box {
            font-size: 1rem;
            font-weight: normal;
            margin-top: 10px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
            text-align: left;
            line-height: 1.7;
        }
        .diff-correct { color: #000; }
        .diff-incorrect { color: #dc3545; text-decoration: underline; font-weight: bold; }
        .diff-missing { color: #6c757d; font-style: italic; }
        #audio-canvas {
            display: block;
            width: 100%;
            height: 60px;
            background-color: #f0f2f5;
            border-radius: 8px;
            margin: 15px 0;
        }
        #score-area {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #ffc107;
            color: #333;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .auto-record-toggle {
            margin-top: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
    </style>
</head>
<body>
    <div id="score-area">ƒêi·ªÉm: 100</div>
    <div class="container">
        <h1>Luy·ªán Giao Ti·∫øp Chuy√™n Nghi·ªáp üöÄ</h1>
        
        <div id="initial-setup">
            <div class="instructions">
                <strong>H∆∞·ªõng d·∫´n:</strong>
                <ol>
                    <li>Ch·ªçn ƒë·ªô kh√≥ v√† t√πy ch·ªânh kh√°c.</li>
                    <li>D√°n ƒëo·∫°n h·ªôi tho·∫°i v√†o √¥ (d√πng "A:" v√† "B:").</li>
                    <li>Nh·∫•n <strong>"B·∫Øt ƒê·∫ßu Luy·ªán T·∫≠p"</strong>.</li>
                    <li>N·∫øu "T·ª± ƒë·ªông ghi √¢m" ƒë∆∞·ª£c b·∫≠t, ·ª©ng d·ª•ng s·∫Ω t·ª± b·∫Øt ƒë·∫ßu nghe sau khi m√°y n√≥i xong.</li>
                    <li>N·∫øu kh√¥ng, b·∫°n c·∫ßn nh·∫•n n√∫t "B·∫Øt ƒê·∫ßu Ghi √Çm".</li>
                </ol>
            </div>

            <div class="settings-grid">
                <div class="difficulty-selection">
                    <fieldset>
                        <legend>Ch·ªçn ƒê·ªô Kh√≥</legend>
                        <div><input type="radio" id="easy" name="difficulty" value="80" checked> <label for="easy">D·ªÖ (80%)</label></div>
                        <div><input type="radio" id="medium" name="difficulty" value="90"> <label for="medium">TB (90%)</label></div>
                        <div><input type="radio" id="hard" name="difficulty" value="100"> <label for="hard">Kh√≥ (100%)</label></div>
                    </fieldset>
                    <div class="auto-record-toggle">
                        <input type="checkbox" id="auto-record" checked>
                        <label for="auto-record">T·ª± ƒë·ªông ghi √¢m</label>
                    </div>
                </div>
                <div class="custom-feedback-area">
                    <textarea id="rewards-input" rows="3" placeholder="Ph·∫ßn th∆∞·ªüng (m·ªói d√≤ng m·ªôt c√¢u)...&#10;L√†m t·ªët l·∫Øm!&#10;Ph√°t √¢m chu·∫©n!">L√†m t·ªët l·∫Øm!&#10;Ph√°t √¢m chu·∫©n!&#10;Tuy·ªát v·ªùi!&#10;B·∫°n th·∫≠t si√™u!</textarea>
                    <textarea id="penalties-input" rows="3" placeholder="H√¨nh ph·∫°t (m·ªói d√≤ng m·ªôt c√¢u)...&#10;C·ªë l√™n n√†o!&#10;Th·ª≠ l·∫°i l·∫ßn n·ªØa nh√©.">C·ªë l√™n n√†o!&#10;Th·ª≠ l·∫°i l·∫ßn n·ªØa nh√©.&#10;ƒê·ª´ng n·∫£n l√≤ng.&#10;S·∫Øp ƒë∆∞·ª£c r·ªìi!</textarea>
                </div>
            </div>

            <div class="settings-grid" style="margin-top: 15px;">
                <div class="custom-feedback-area">
                    <label for="success-audio">√Çm thanh khi th√†nh c√¥ng (.mp3):</label>
                    <input type="file" id="success-audio" accept=".mp3">
                </div>
                <div class="custom-feedback-area">
                    <label for="failure-audio">√Çm thanh khi th·∫•t b·∫°i (.mp3):</label>
                    <input type="file" id="failure-audio" accept=".mp3">
                </div>
            </div>

            <textarea id="dialogue-input" rows="6" placeholder="D√°n h·ªôi tho·∫°i c·ªßa b·∫°n ·ªü ƒë√¢y...&#10;V√≠ d·ª•:&#10;A: Hello, how are you?&#10;B: I'm fine, thank you. And you?"></textarea>
            
            <div class="controls">
                <button id="load-btn">üöÄ B·∫Øt ƒê·∫ßu Luy·ªán T·∫≠p</button>
                <button id="swap-roles-btn">üîÅ ƒê·ªïi Vai (Hi·ªán t·∫°i: B·∫°n l√† B)</button>
            </div>
        </div>

        <div id="practice-area" class="dialogue-box" style="display: none;">
            <h2>L·ªùi tho·∫°i c·ªßa m√°y:</h2>
            <div id="computer-line" class="line computer-line">...</div>
            <div id="user-line-container">
                 <h2 id="user-line-title">C√¢u c·ªßa b·∫°n:</h2>
                 <div id="user-line" class="line user-line" style="display: none;">...</div>
            </div>
        </div>
        
        <div id="status-area" class="status"></div>
        
        <div id="interim-transcript-area" class="feedback-box" style="display: none; margin-top: 15px; min-height: 50px; font-style: italic; color: #6c757d;"></div>
        
        <canvas id="audio-canvas" style="display: none;"></canvas>

        <div id="session-controls-area" style="display: none;">
            <div class="session-controls">
                <button id="record-btn" disabled>üé§ B·∫Øt ƒê·∫ßu Ghi √Çm</button>
                <button id="toggle-line-btn" disabled>üôà Hi·ªán L·ªùi Tho·∫°i</button>
            </div>
        </div>
        
        <div id="review-area" style="display: none;">
            <h2>Xem L·∫°i H·ªôi Tho·∫°i</h2>
            <div id="review-content"></div>
            <div class="controls" style="margin-top: 20px;">
                <button id="play-all-btn">‚ñ∂Ô∏è Nghe l·∫°i to√†n b·ªô</button>
                <button id="restart-btn">Luy·ªán t·∫≠p l·∫°i</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. L·∫•y c√°c ph·∫ßn t·ª≠ HTML ---
        const dialogueInput = document.getElementById('dialogue-input');
        const loadBtn = document.getElementById('load-btn');
        const swapRolesBtn = document.getElementById('swap-roles-btn');
        const toggleBtn = document.getElementById('toggle-line-btn');
        const recordBtn = document.getElementById('record-btn');
        const practiceArea = document.getElementById('practice-area');
        const computerLine = document.getElementById('computer-line');
        const userLine = document.getElementById('user-line');
        const userLineTitle = document.getElementById('user-line-title');
        const statusArea = document.getElementById('status-area');
        const initialSetup = document.getElementById('initial-setup');
        const sessionControlsArea = document.getElementById('session-controls-area');
        const reviewArea = document.getElementById('review-area');
        const reviewContent = document.getElementById('review-content');
        const restartBtn = document.getElementById('restart-btn');
        const playAllBtn = document.getElementById('play-all-btn');
        const rewardsInput = document.getElementById('rewards-input');
        const penaltiesInput = document.getElementById('penalties-input');
        const scoreArea = document.getElementById('score-area');
        const canvas = document.getElementById('audio-canvas');
        const canvasCtx = canvas.getContext('2d');
        const autoRecordCheckbox = document.getElementById('auto-record');
        const interimTranscriptArea = document.getElementById('interim-transcript-area');
        const successAudioInput = document.getElementById('success-audio');
        const failureAudioInput = document.getElementById('failure-audio');

        // --- 2. Kh·ªüi t·∫°o Web API & Bi·∫øn tr·∫°ng th√°i ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const synthesis = window.speechSynthesis;
        let recognition;
        let voices = [];
        let mediaRecorder;
        let audioChunks = [];
        
        let linesA = [], linesB = [], userRecordings = [];
        let currentLineIndex = 0;
        let userIsB = true; 
        let isUserLineVisible = false;
        let score = 100;
        let isRecording = false;
        
        let successAudioURL = null;
        let failureAudioURL = null;
        let currentFailureAudio = null; // Bi·∫øn ƒë·ªÉ gi·ªØ tham chi·∫øu ƒë·∫øn √¢m thanh th·∫•t b·∫°i ƒëang ph√°t

        // Audio visualizer variables
        let audioContext, analyser, source, animationFrameId;
        
        // Variables for smarter recognition
        let silenceTimeout;
        let final_transcript = '';

        if (SpeechRecognition && synthesis && navigator.mediaDevices) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'zh-CN';
        } else {
            statusArea.textContent = "L·ªói: Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Speech API ho·∫∑c MediaStream.";
            [loadBtn, swapRolesBtn, toggleBtn, recordBtn].forEach(b => b.disabled = true);
        }
        
        function loadVoices() { voices = synthesis.getVoices(); }
        loadVoices();
        if (synthesis.onvoiceschanged !== undefined) { synthesis.onvoiceschanged = loadVoices; }

        // --- 3. C√°c h√†m ch·ª©c nƒÉng ---

        function speak(text, onEndCallback) {
            if (synthesis.speaking) { synthesis.cancel(); }
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.voice = voices.find(voice => voice.name === 'Microsoft Xiaoxiao Online (Natural) - Chinese (Mainland)') || voices.find(voice => voice.lang === 'zh-CN');
            utterance.onend = () => onEndCallback && onEndCallback();
            synthesis.speak(utterance);
        }

        function playAudioPromise(url) {
            return new Promise((resolve, reject) => {
                if (!url) {
                    resolve();
                    return;
                }
                const audio = new Audio(url);
                audio.onended = resolve;
                audio.onerror = reject;
                audio.play();
            });
        }

        function lcs(seq1, seq2) {
            const m = seq1.length, n = seq2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (seq1[i - 1] === seq2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                    }
                }
            }
            let i = m, j = n;
            const result = [];
            while (i > 0 && j > 0) {
                if (seq1[i - 1] === seq2[j - 1]) {
                    result.unshift(seq1[i - 1]);
                    i--; j--;
                } else if (dp[i - 1][j] > dp[i][j - 1]) {
                    i--;
                } else {
                    j--;
                }
            }
            return result;
        }

        function createDiffHtml(originalText, spokenText) {
            const clean = (text) => text.toLowerCase().replace(/[^\w\s']/g, "").split(/\s+/).filter(Boolean);
            const originalWords = clean(originalText);
            const spokenWords = clean(spokenText);
            const commonSubsequence = new Set(lcs(originalWords, spokenWords));
            
            let correctWords = 0;
            const spokenHtml = spokenWords.map(word => {
                if (commonSubsequence.has(word)) {
                    correctWords++;
                    return `<span class="diff-correct">${word}</span>`;
                } else {
                    return `<span class="diff-incorrect">${word}</span>`;
                }
            }).join(' ');

            const originalHtml = originalWords.map(word => {
                if (commonSubsequence.has(word)) {
                    return `<span class="diff-correct">${word}</span>`;
                } else {
                    return `<span class="diff-missing">${word}</span>`;
                }
            }).join(' ');
            
            const accuracy = originalWords.length > 0 ? Math.round((correctWords / originalWords.length) * 100) : 0;
            
            return {
                html: `<div><strong>C√¢u tho·∫°i g·ªëc:</strong> ${originalHtml}</div><div><strong>B·∫°n ƒë√£ n√≥i:</strong> ${spokenHtml}</div>`,
                accuracy: accuracy
            };
        }

        function updateDialogueDisplay() {
            const computerRole = userIsB ? 'A' : 'B';
            const userRole = userIsB ? 'B' : 'A';
            const computerText = userIsB ? linesA[currentLineIndex] : linesB[currentLineIndex];
            const userText = userIsB ? linesB[currentLineIndex] : linesA[currentLineIndex];
            computerLine.textContent = `${computerRole} (M√°y): ${computerText || '...'}`;
            userLine.textContent = userText || '...';
            userLineTitle.textContent = `C√¢u c·ªßa b·∫°n (${userRole}):`;
            userLine.style.display = isUserLineVisible ? 'block' : 'none';
            toggleBtn.textContent = isUserLineVisible ? 'üôâ ·∫®n L·ªùi Tho·∫°i' : 'üôà Hi·ªán L·ªùi Tho·∫°i';
            swapRolesBtn.textContent = `üîÅ ƒê·ªïi Vai (Hi·ªán t·∫°i: B·∫°n l√† ${userRole})`;
        }

        function startPractice() {
            currentLineIndex = 0;
            userRecordings = [];
            score = 100;
            updateScoreDisplay();
            statusArea.innerHTML = '';
            statusArea.className = 'status';
            initialSetup.style.display = 'none';
            reviewArea.style.display = 'none';
            practiceArea.style.display = 'block';
            sessionControlsArea.style.display = 'block';
            canvas.style.display = 'block';
            [toggleBtn].forEach(b => b.disabled = false);
            updateDialogueDisplay();
            recordBtn.disabled = true;
            recordBtn.textContent = '...';

            if (userIsB) {
                statusArea.textContent = 'Vai A (M√°y) ƒëang n√≥i...';
                speak(linesA[0], handleNextTurn);
            } else {
                statusArea.textContent = 'ƒê·∫øn l∆∞·ª£t b·∫°n (Vai A).';
                computerLine.textContent = `B (M√°y): ...ch·ªù b·∫°n n√≥i...`;
                handleNextTurn();
            }
        }
        
        function showReview() {
            practiceArea.style.display = 'none';
            sessionControlsArea.style.display = 'none';
            canvas.style.display = 'none';
            
            if (score >= 80) {
                const rewardMsg = getRandomItem(rewardsInput.value) || "Ch√∫c m·ª´ng!";
                statusArea.innerHTML = `üéâ ${rewardMsg} B·∫°n ƒë√£ ho√†n th√†nh v·ªõi s·ªë ƒëi·ªÉm ${score}!`;
                statusArea.className = 'status success';
            } else {
                const penaltyMsg = getRandomItem(penaltiesInput.value) || "C·ªë g·∫Øng h∆°n nh√©!";
                statusArea.innerHTML = `ü§î ${penaltyMsg} B·∫°n ch·ªâ ƒë·∫°t ${score} ƒëi·ªÉm. Luy·ªán t·∫≠p th√™m nh√©!`;
                statusArea.className = 'status error';
            }

            reviewArea.style.display = 'block';
            reviewContent.innerHTML = '';
            const userRole = userIsB ? 'B' : 'A';
            const createPlayHandler = index => () => {
                const audioBlob = userRecordings[index];
                if (audioBlob) { const audioUrl = URL.createObjectURL(audioBlob); new Audio(audioUrl).play(); }
            };
            for (let i = 0; i < linesA.length; i++) {
                const lineA = document.createElement('div'); lineA.classList.add('review-line');
                if (userRole === 'A') {
                    lineA.classList.add('user'); const text = document.createElement('span'); text.textContent = `A (B·∫°n): ${linesA[i]}`;
                    const playBtn = document.createElement('button'); playBtn.textContent = '‚ñ∂Ô∏è'; playBtn.classList.add('play-recording-btn');
                    playBtn.onclick = createPlayHandler(i); lineA.appendChild(text); lineA.appendChild(playBtn);
                } else { lineA.classList.add('computer'); lineA.textContent = `A (M√°y): ${linesA[i]}`; }
                reviewContent.appendChild(lineA);
                if (linesB[i]) {
                    const lineB = document.createElement('div'); lineB.classList.add('review-line');
                    if (userRole === 'B') {
                        lineB.classList.add('user'); const text = document.createElement('span'); text.textContent = `B (B·∫°n): ${linesB[i]}`;
                        const playBtn = document.createElement('button'); playBtn.textContent = '‚ñ∂Ô∏è'; playBtn.classList.add('play-recording-btn');
                        playBtn.onclick = createPlayHandler(i); lineB.appendChild(text); lineB.appendChild(playBtn);
                    } else { lineB.classList.add('computer'); lineB.textContent = `B (M√°y): ${linesB[i]}`; }
                    reviewContent.appendChild(lineB);
                }
            }
        }

        function updateScoreDisplay() {
            scoreArea.textContent = `ƒêi·ªÉm: ${score}`;
        }

        function getRandomItem(list) {
            const items = list.split('\n').filter(item => item.trim() !== '');
            if (items.length === 0) return '';
            return items[Math.floor(Math.random() * items.length)];
        }

        function setupAudioVisualizer(stream) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            source.connect(analyser);
            drawWaveform();
        }

        function drawWaveform() {
            animationFrameId = requestAnimationFrame(drawWaveform);
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            canvasCtx.fillStyle = '#f0f2f5';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#0d6efd';
            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;
                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();
        }

        function stopDrawing() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            canvasCtx.fillStyle = '#f0f2f5';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // --- 4. G·∫Øn c√°c s·ª± ki·ªán ---
        loadBtn.addEventListener('click', () => {
            const fullText = dialogueInput.value.trim(); if (fullText === '') { alert('Vui l√≤ng nh·∫≠p ƒëo·∫°n h·ªôi tho·∫°i!'); return; }
            const lines = fullText.split('\n').filter(line => line.trim() !== ''); linesA = []; linesB = [];
            lines.forEach(line => {
                if (line.toLowerCase().startsWith('a:')) linesA.push(line.substring(2).trim());
                else if (line.toLowerCase().startsWith('b:')) linesB.push(line.substring(2).trim());
            });
            if (linesA.length === 0 || (linesB.length > 0 && linesA.length !== linesB.length)) { 
                alert('L·ªói: S·ªë l∆∞·ª£ng c√¢u tho·∫°i c·ªßa A v√† B ph·∫£i b·∫±ng nhau (n·∫øu B t·ªìn t·∫°i) v√† kh√¥ng ƒë∆∞·ª£c r·ªóng!'); 
                return; 
            }
            startPractice();
        });

        swapRolesBtn.addEventListener('click', () => { 
            userIsB = !userIsB; 
            if (linesA.length > 0) { 
                startPractice(); 
            } else { 
                updateDialogueDisplay(); 
            } 
        });

        toggleBtn.addEventListener('click', () => { 
            isUserLineVisible = !isUserLineVisible; 
            userLine.style.display = isUserLineVisible ? 'block' : 'none'; 
            toggleBtn.textContent = isUserLineVisible ? 'üôâ ·∫®n L·ªùi Tho·∫°i' : 'üôà Hi·ªán L·ªùi Tho·∫°i'; 
        });

        // H√ÄM ƒê√É C·∫¨P NH·∫¨T
        function startRecording() {
            // D·ª´ng √¢m thanh th·∫•t b·∫°i n·∫øu ƒëang ph√°t khi ng∆∞·ªùi d√πng th·ª≠ l·∫°i
            if (currentFailureAudio) {
                currentFailureAudio.pause();
                currentFailureAudio.currentTime = 0; // Reset th·ªùi gian v·ªÅ ƒë·∫ßu
                currentFailureAudio = null;
            }
        
            if (isRecording) return; 
        
            isRecording = true;
            final_transcript = '';
            interimTranscriptArea.textContent = 'ƒêang nghe...';
            interimTranscriptArea.style.display = 'block';
            
            recordBtn.disabled = true;
            recordBtn.textContent = 'üî¥ ƒêang ghi √¢m...';
            statusArea.textContent = 'B·∫Øt ƒë·∫ßu ghi √¢m... üé§';
            statusArea.className = 'status';
            
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                setupAudioVisualizer(stream);
                mediaRecorder = new MediaRecorder(stream); 
                mediaRecorder.start(); 
                audioChunks = [];
                mediaRecorder.addEventListener("dataavailable", e => { audioChunks.push(e.data); });
                mediaRecorder.addEventListener("stop", () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    userRecordings[currentLineIndex] = audioBlob; 
                    stream.getTracks().forEach(t => t.stop());
                    if (audioContext && audioContext.state !== 'closed') {
                        audioContext.close().then(() => audioContext = null);
                    }
                });
                recognition.start();
            }).catch(err => { 
                statusArea.textContent = `L·ªói truy c·∫≠p microphone: ${err.message}`; 
                statusArea.className = 'status error'; 
                recordBtn.disabled = false; 
                recordBtn.textContent = 'üé§ Th·ª≠ L·∫°i';
                isRecording = false;
                interimTranscriptArea.style.display = 'none';
            });
        }
        
        recordBtn.addEventListener('click', startRecording);
        
        function handleNextTurn() {
            if (autoRecordCheckbox.checked) {
                statusArea.textContent = 'ƒê·∫øn l∆∞·ª£t b·∫°n. Chu·∫©n b·ªã ghi √¢m...';
                setTimeout(startRecording, 500);
            } else {
                statusArea.textContent = 'ƒê·∫øn l∆∞·ª£t b·∫°n. H√£y nh·∫•n n√∫t ƒë·ªÉ ghi √¢m.';
                recordBtn.disabled = false;
                recordBtn.textContent = 'üé§ B·∫Øt ƒê·∫ßu Ghi √Çm';
            }
        }
        
        // H√ÄM ƒê√É C·∫¨P NH·∫¨T
        async function processFinalResult(spokenText) {
            if (!isRecording) return;
            isRecording = false; 

            const targetText = userIsB ? linesB[currentLineIndex] : linesA[currentLineIndex];
            const difficultyThreshold = parseInt(document.querySelector('input[name="difficulty"]:checked').value);
            const { html: diffHtml, accuracy } = createDiffHtml(targetText, spokenText.trim());

            if (accuracy >= difficultyThreshold) {
                statusArea.className = 'status success';
                const rewardMsg = getRandomItem(rewardsInput.value);
                statusArea.innerHTML = `${rewardMsg} (ƒê·ªô ch√≠nh x√°c: ${accuracy}%)`;
                
                await playAudioPromise(successAudioURL);

                currentLineIndex++;
                const conversationLength = Math.max(linesA.length, linesB.length);
                if (currentLineIndex >= conversationLength) {
                    setTimeout(showReview, 1000);
                    return;
                }
                
                updateDialogueDisplay();
                const nextLineToSpeak = userIsB ? linesA[currentLineIndex] : (linesB[currentLineIndex] || null);
                if (nextLineToSpeak) {
                    statusArea.textContent = 'M√°y ƒëang n√≥i...';
                    recordBtn.disabled = true;
                    recordBtn.textContent = '...';
                    await speakPromise(nextLineToSpeak);
                    handleNextTurn();
                } else {
                    handleNextTurn();
                }

            } else {
                statusArea.className = 'status error';
                score -= 5;
                updateScoreDisplay();
                const penaltyMsg = getRandomItem(penaltiesInput.value);
                statusArea.innerHTML = `
                    <div style="margin-bottom: 10px;">${penaltyMsg} (${accuracy}%). Th·ª≠ l·∫°i nh√©! (-5 ƒëi·ªÉm)</div>
                    <div class="feedback-box">${diffHtml}</div>
                `;
                
                if (failureAudioURL) {
                    if (currentFailureAudio) {
                        currentFailureAudio.pause();
                    }
                    currentFailureAudio = new Audio(failureAudioURL);
                    currentFailureAudio.play();
                    currentFailureAudio.onended = () => {
                        currentFailureAudio = null;
                    };
                }

                recordBtn.disabled = false;
                recordBtn.textContent = 'üé§ Th·ª≠ L·∫°i';
            }
        }
        
        recognition.onresult = (event) => {
            clearTimeout(silenceTimeout);
            let interim_transcript = '';
            final_transcript = ''; 
            
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    final_transcript += event.results[i][0].transcript;
                } else {
                    interim_transcript += event.results[i][0].transcript;
                }
            }

            interimTranscriptArea.textContent = interim_transcript;

            silenceTimeout = setTimeout(() => {
                recognition.stop();
            }, 2500);
        };
        
        recognition.onend = () => {
            stopDrawing();
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
            
            interimTranscriptArea.style.display = 'none';

            if (final_transcript && isRecording) {
                processFinalResult(final_transcript);
            } else if (isRecording) {
                isRecording = false;
                recordBtn.disabled = false;
                recordBtn.textContent = 'üé§ Th·ª≠ L·∫°i';
                statusArea.textContent = "Kh√¥ng nghe th·∫•y gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i.";
                statusArea.className = 'status error';
            }
        };

        recognition.onerror = (event) => { 
            if (event.error !== 'no-speech') {
                 statusArea.textContent = `L·ªói: ${event.error}. Vui l√≤ng th·ª≠ l·∫°i.`; 
                 statusArea.className = 'status error'; 
            }
            isRecording = false;
            recordBtn.disabled = false;
            interimTranscriptArea.style.display = 'none';
        };
        
        restartBtn.addEventListener('click', () => { 
            reviewArea.style.display = 'none'; 
            initialSetup.style.display = 'block'; 
            practiceArea.style.display = 'none'; 
            sessionControlsArea.style.display = 'none'; 
            canvas.style.display = 'none';
            statusArea.innerHTML = ''; 
            statusArea.className = 'status';
            dialogueInput.value = ''; 
            linesA = []; linesB = []; userRecordings = []; currentLineIndex = 0; 
            score = 100;
            updateScoreDisplay();
        });
        
        function playAudioBlob(blob) { return new Promise((resolve, reject) => { if (!blob) { resolve(); return; } const audioUrl = URL.createObjectURL(blob); const audio = new Audio(audioUrl); audio.onended = resolve; audio.onerror = reject; audio.play(); }); }
        function speakPromise(text) { return new Promise(resolve => { speak(text, resolve); }); }
        
        playAllBtn.addEventListener('click', async () => {
            playAllBtn.disabled = true; 
            restartBtn.disabled = true; 
            document.querySelectorAll('.play-recording-btn').forEach(btn => btn.disabled = true);
            statusArea.textContent = 'ƒêang ph√°t l·∫°i to√†n b·ªô h·ªôi tho·∫°i...'; 
            statusArea.className = 'status';
            try {
                const conversationLength = Math.max(linesA.length, linesB.length);
                for (let i = 0; i < conversationLength; i++) {
                    const lineA = linesA[i];
                    const lineB = linesB[i];
                    const recording = userRecordings[i];

                    if (userIsB) {
                        if (lineA) await speakPromise(lineA);
                        if (recording) await playAudioBlob(recording);
                    } else {
                        if (recording) await playAudioBlob(recording);
                        if (lineB) await speakPromise(lineB);
                    }
                }
            } catch (error) { 
                console.error("Playback failed:", error); 
                statusArea.textContent = 'L·ªói khi ph√°t l·∫°i.'; 
                statusArea.className = 'status error';
            } finally {
                playAllBtn.disabled = false; 
                restartBtn.disabled = false; 
                document.querySelectorAll('.play-recording-btn').forEach(btn => btn.disabled = false);
                statusArea.innerHTML = 'üéâ Ph√°t l·∫°i ho√†n t·∫•t! üéâ';
                statusArea.className = 'status success';
            }
        });

        successAudioInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                if (successAudioURL) URL.revokeObjectURL(successAudioURL);
                successAudioURL = URL.createObjectURL(file);
                console.log("ƒê√£ t·∫£i √¢m thanh th√†nh c√¥ng:", successAudioURL);
            }
        });

        failureAudioInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                if (failureAudioURL) URL.revokeObjectURL(failureAudioURL);
                failureAudioURL = URL.createObjectURL(file);
                console.log("ƒê√£ t·∫£i √¢m thanh th·∫•t b·∫°i:", failureAudioURL);
            }
        });

    </script>
</body>
</html>
